'use strict';

const unhead = require('unhead');
const vue = require('vue');
const shared = require('@unhead/shared');

function resolveUnref(r) {
  return typeof r === "function" ? r() : vue.unref(r);
}
function resolveUnrefHeadInput(ref, lastKey = "") {
  if (ref instanceof Promise)
    return ref;
  const root = resolveUnref(ref);
  if (!ref || !root)
    return root;
  if (Array.isArray(root))
    return root.map((r) => resolveUnrefHeadInput(r, lastKey));
  if (typeof root === "object") {
    let dynamic = false;
    const unrefdObj = Object.fromEntries(
      Object.entries(root).map(([k, v]) => {
        if (k === "titleTemplate" || k.startsWith("on"))
          return [k, vue.unref(v)];
        if (typeof v === "function" || vue.isRef(v))
          dynamic = true;
        return [k, resolveUnrefHeadInput(v, k)];
      })
    );
    if (dynamic && shared.HasElementTags.includes(String(lastKey)))
      unrefdObj._dynamic = true;
    return unrefdObj;
  }
  return root;
}

const Vue3 = vue.version.startsWith("3");
const IsBrowser = typeof window !== "undefined";

const headSymbol = "usehead";
function injectHead() {
  return vue.getCurrentInstance() && vue.inject(headSymbol) || unhead.getActiveHead();
}
function createHead(options = {}) {
  const head = unhead.createHead({
    ...options,
    // arbitrary delay the dom update for batch updates
    domDelayFn: (fn) => setTimeout(() => vue.nextTick(() => fn()), 10),
    plugins: [
      VueReactiveUseHeadPlugin(),
      ...options?.plugins || []
    ]
  });
  const vuePlugin = {
    install(app) {
      if (Vue3) {
        app.config.globalProperties.$unhead = head;
        app.provide(headSymbol, head);
      }
    }
  };
  head.install = vuePlugin.install;
  return head;
}

const VueHeadMixin = {
  created() {
    const instance = vue.getCurrentInstance();
    if (!instance)
      return;
    const options = instance.type;
    if (!options || !("head" in options))
      return;
    const source = typeof options.head === "function" ? () => options.head.call(instance.proxy) : options.head;
    useHead(source);
  }
};

const VueReactiveUseHeadPlugin = () => {
  return shared.defineHeadPlugin({
    hooks: {
      "entries:resolve": function(ctx) {
        for (const entry of ctx.entries)
          entry.resolvedInput = resolveUnrefHeadInput(entry.input);
      }
    }
  });
};

const Vue2ProvideUnheadPlugin = function(_Vue, head) {
  _Vue.mixin({
    beforeCreate() {
      const options = this.$options;
      const origProvide = options.provide;
      options.provide = function() {
        let origProvideResult;
        if (typeof origProvide === "function")
          origProvideResult = origProvide.call(this);
        else
          origProvideResult = origProvide || {};
        return {
          ...origProvideResult,
          [headSymbol]: head
        };
      };
    }
  });
};

function clientUseHead(input, options = {}) {
  const head = injectHead();
  const deactivated = vue.ref(false);
  const resolvedInput = vue.ref({});
  vue.watchEffect(() => {
    resolvedInput.value = deactivated.value ? {} : resolveUnrefHeadInput(input);
  });
  const entry = head.push(resolvedInput.value, options);
  vue.watch(resolvedInput, (e) => {
    entry.patch(e);
  });
  const vm = vue.getCurrentInstance();
  if (vm) {
    vue.onBeforeUnmount(() => {
      entry.dispose();
    });
    vue.onDeactivated(() => {
      deactivated.value = true;
    });
    vue.onActivated(() => {
      deactivated.value = false;
    });
  }
  return entry;
}

function serverUseHead(input, options = {}) {
  const head = injectHead();
  return head.push(input, options);
}

function useServerHead(input, options = {}) {
  return useHead(input, { ...options, mode: "server" });
}
const useServerTagTitle = (title) => useServerHead({ title });
const useServerTitleTemplate = (titleTemplate) => useServerHead({ titleTemplate });
const useServerTagMeta = (meta) => useServerHead({ meta: shared.asArray(meta) });
const useServerTagMetaFlat = (meta) => {
  const input = vue.ref({});
  vue.watchEffect(() => {
    input.value = unhead.unpackMeta(resolveUnrefHeadInput(meta));
  });
  return useServerHead({ meta: input });
};
const useServerTagLink = (link) => useServerHead({ link: shared.asArray(link) });
const useServerTagScript = (script) => useServerHead({ script: shared.asArray(script) });
const useServerTagStyle = (style) => useServerHead({ style: shared.asArray(style) });
const useServerTagNoscript = (noscript) => useServerHead({ noscript: shared.asArray(noscript) });
const useServerTagBase = (base) => useServerHead({ base });
const useServerHtmlAttrs = (attrs) => useServerHead({ htmlAttrs: attrs });
const useServerBodyAttrs = (attrs) => useHead({ bodyAttrs: attrs });

const useSeoMeta = (input) => {
  const headInput = vue.ref({});
  vue.watchEffect(() => {
    const resolvedMeta = resolveUnrefHeadInput(input);
    const { title, titleTemplate, ...meta } = resolvedMeta;
    headInput.value = {
      title,
      titleTemplate,
      meta: unhead.unpackMeta(meta)
    };
  });
  return useHead(headInput);
};

function useHead(input, options = {}) {
  const head = injectHead();
  if (head) {
    const isBrowser = IsBrowser || !!head.resolvedOptions?.document;
    if (options.mode === "server" && isBrowser || options.mode === "client" && !isBrowser)
      return;
    return isBrowser ? clientUseHead(input, options) : serverUseHead(input, options);
  }
}
const useTagTitle = (title) => useHead({ title });
const useTitleTemplate = (titleTemplate) => useHead({ titleTemplate });
const useTagMeta = (meta) => useHead({ meta: shared.asArray(meta) });
const useTagMetaFlat = (meta) => {
  const input = vue.ref({});
  vue.watchEffect(() => {
    input.value = unhead.unpackMeta(resolveUnrefHeadInput(meta));
  });
  return useHead({ meta: input });
};
const useTagLink = (link) => useHead({ link: shared.asArray(link) });
const useTagScript = (script) => useHead({ script: shared.asArray(script) });
const useTagStyle = (style) => useHead({ style: shared.asArray(style) });
const useTagNoscript = (noscript) => useHead({ noscript: shared.asArray(noscript) });
const useTagBase = (base) => useHead({ base });
const useHtmlAttrs = (attrs) => useHead({ htmlAttrs: attrs });
const useBodyAttrs = (attrs) => useHead({ bodyAttrs: attrs });

const coreComposableNames = [
  "injectHead"
];
const unheadVueComposablesImports = {
  "@unhead/vue": [...coreComposableNames, ...unhead.composableNames]
};

exports.createHeadCore = unhead.createHeadCore;
exports.Vue2ProvideUnheadPlugin = Vue2ProvideUnheadPlugin;
exports.VueHeadMixin = VueHeadMixin;
exports.VueReactiveUseHeadPlugin = VueReactiveUseHeadPlugin;
exports.createHead = createHead;
exports.headSymbol = headSymbol;
exports.injectHead = injectHead;
exports.resolveUnrefHeadInput = resolveUnrefHeadInput;
exports.unheadVueComposablesImports = unheadVueComposablesImports;
exports.useBodyAttrs = useBodyAttrs;
exports.useHead = useHead;
exports.useHtmlAttrs = useHtmlAttrs;
exports.useSeoMeta = useSeoMeta;
exports.useServerBodyAttrs = useServerBodyAttrs;
exports.useServerHead = useServerHead;
exports.useServerHtmlAttrs = useServerHtmlAttrs;
exports.useServerTagBase = useServerTagBase;
exports.useServerTagLink = useServerTagLink;
exports.useServerTagMeta = useServerTagMeta;
exports.useServerTagMetaFlat = useServerTagMetaFlat;
exports.useServerTagNoscript = useServerTagNoscript;
exports.useServerTagScript = useServerTagScript;
exports.useServerTagStyle = useServerTagStyle;
exports.useServerTagTitle = useServerTagTitle;
exports.useServerTitleTemplate = useServerTitleTemplate;
exports.useTagBase = useTagBase;
exports.useTagLink = useTagLink;
exports.useTagMeta = useTagMeta;
exports.useTagMetaFlat = useTagMetaFlat;
exports.useTagNoscript = useTagNoscript;
exports.useTagScript = useTagScript;
exports.useTagStyle = useTagStyle;
exports.useTagTitle = useTagTitle;
exports.useTitleTemplate = useTitleTemplate;
